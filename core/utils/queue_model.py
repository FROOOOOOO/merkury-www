import numpy as np
import decimal
import math
import seaborn as sns
import matplotlib.pyplot as plt
from scipy import interpolate
from scipy.interpolate import griddata
from core.utils import utils


def interpolate_fitting(x, y, kind='linear', plot=False):
    f_interpolate = interpolate.interp1d(x, y, kind=kind)
    if plot:
        plt.scatter(x, y, marker='x', color='r')
        xx = np.linspace(x.min(), x.max(), 100)
        plt.plot(xx, f_interpolate(xx), color='b')
        plt.xlabel('Concurrency (req)')
        plt.ylabel('CPU utilization (core)')
        plt.title('CPU utilization - Concurrency Mapping')
    return f_interpolate


def get_concurrency_rec(x, y):
    indices = np.where(y == np.max(y))
    return int(np.min(x[indices]))


def check_monotonicity(file: str, ftype: str = '2d') -> (dict, list):  # type: ignore
    """check the monotonicity of p_r, l, w, l_q, w_q, l_e, w_e with c*, f* (both for ftype=2d and 3d), q* (only for
    ftype=3d)

    Args:
        file (str): file generated by QueueModel(withTruncation).run()
        ftype (str): 2d (independent var: c*, f*) or 3d (ind var: c*, f*, q*)

    Returns:
        dict : consists of int (-1: ↓, 1: ↑, 0: unkown, other: no monotonicity) indicating monotonicity
    """
    if ftype not in ['2d', '3d']:
        raise ValueError('ftype must be either 2d or 3d')
    # constants
    metrics = ['p_r', 'l', 'w', 'l_q', 'w_q', 'l_e', 'w_e']
    ind_var = ['c*', 'f*']
    if ftype == '3d':
        ind_var.append('q*')
    # data
    mlist = dict()
    for metric in metrics:
        mlist[metric] = []
    vlist = dict()
    for var in ind_var:
        vlist[var] = []
    # result
    mono = {}
    for metric in metrics:
        mono[metric] = dict()
        for var in ind_var:
            mono[metric][var] = 0
    violations = []
    # read file
    with open(file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    for line in lines:
        line = line.strip()
        # read data
        if line.startswith('c*'):
            vlist['c*'].append(float(line.split('=')[1]))
        elif line.startswith('f*'):
            vlist['f*'].append(int(line.split('=')[1]))
        elif ftype == '3d' and line.startswith('q*'):
            vlist['q*'].append(int(line.split('=')[1]))
        elif line.startswith('overload'):
            for var in vlist:
                vlist[var].pop()
        elif line.startswith('p_reject('):
            mlist['p_r'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L('):
            mlist['l'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W('):
            mlist['w'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L_q('):
            mlist['l_q'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W_q('):
            mlist['w_q'].append(decimal.Decimal(line.split('≈')[1]))
    for var in vlist:
        if var == 'c*':
            vlist[var] = np.array(vlist[var]).astype(float)
        else:
            vlist[var] = np.array(vlist[var]).astype(int)
    for metric in mlist:
        if metric == 'l_e':
            mlist[metric] = np.subtract(mlist['l'], mlist['l_q'])
        elif metric == 'w_e':
            mlist[metric] = np.subtract(mlist['w'], mlist['w_q'])
        else:
            mlist[metric] = np.array(mlist[metric]).astype(float)
    f_unique_list = np.unique(vlist['f*'])
    c_unique_list = np.unique(vlist['c*'])
    if ftype == '3d':  # check 3d file
        q_unique_list = np.unique(vlist['q*'])
        # check monotonicity with c*
        for f in f_unique_list:
            for q in q_unique_list:
                c_last = 0.0
                mlast = dict()
                for metric in metrics:
                    mlast[metric] = 0.0
                indices = np.where((vlist['f*'] == f) & (vlist['q*'] == q))[0]
                for i, j in enumerate(indices):
                    for metric in metrics:
                        if i != 0:
                            if mono[metric]['c*'] == 0:
                                if vlist['c*'][j] > c_last and mlist[metric][j] > mlast[metric]:
                                    mono[metric]['c*'] = 1
                                elif vlist['c*'][j] > c_last and mlist[metric][j] < mlast[metric]:
                                    mono[metric]['c*'] = -1
                            elif mono[metric]['c*'] == 1:
                                if vlist['c*'][j] > c_last and mlast[metric] - mlist[metric][j] > utils.MARGIN_ERROR:
                                    mono[metric]['c*'] = -2
                                    violations.append(
                                        '{expected: ↑, (f*, q*): (%d, %d), last (c*, %s): (%f, %f), current (c*, '
                                        '%s): (%f, %f)}'
                                        % (
                                            f, q, metric, c_last, mlast[metric], metric, vlist['c*'][j],
                                            mlist[metric][j]))
                            elif mono[metric]['c*'] == -1:
                                if vlist['c*'][j] > c_last and mlist[metric][j] - mlast[metric] > utils.MARGIN_ERROR:
                                    mono[metric]['c*'] = 2
                                    violations.append(
                                        '{expected: ↓, (f*, q*): (%d, %d), last (c*, %s): (%f, %f), current (c*, '
                                        '%s): (%f, %f)}'
                                        % (
                                            f, q, metric, c_last, mlast[metric], metric, vlist['c*'][j],
                                            mlist[metric][j]))
                        mlast[metric] = mlist[metric][j]
                    c_last = vlist['c*'][j]
        # check monotonicity with f*
        for c in c_unique_list:
            for q in q_unique_list:
                f_last = 0
                mlast = dict()
                for metric in metrics:
                    mlast[metric] = 0.0
                indices = np.where((vlist['c*'] == c) & (vlist['q*'] == q))[0]
                for i, j in enumerate(indices):
                    for metric in metrics:
                        if i != 0:
                            if mono[metric]['f*'] == 0:
                                if vlist['f*'][j] > f_last and mlist[metric][j] > mlast[metric]:
                                    mono[metric]['f*'] = 1
                                elif vlist['f*'][j] > f_last and mlist[metric][j] < mlast[metric]:
                                    mono[metric]['f*'] = -1
                            elif mono[metric]['f*'] == 1:
                                if vlist['f*'][j] > f_last and mlast[metric] - mlist[metric][j] > utils.MARGIN_ERROR:
                                    mono[metric]['f*'] = -2
                                    violations.append(
                                        '{expected: ↑, (c*, q*): (%f, %d), last (f*, %s): (%d, %f), current (f*, '
                                        '%s): (%d, %f)}'
                                        % (
                                            c, q, metric, f_last, mlast[metric], metric, vlist['f*'][j],
                                            mlist[metric][j]))
                            elif mono[metric]['f*'] == -1:
                                if vlist['f*'][j] > f_last and mlist[metric][j] - mlast[metric] > utils.MARGIN_ERROR:
                                    mono[metric]['f*'] = 2
                                    violations.append(
                                        '{expected: ↓, (c*, q*): (%f, %d), last (f*, %s): (%d, %f), current (f*, '
                                        '%s): (%d, %f)}'
                                        % (
                                            c, q, metric, f_last, mlast[metric], metric, vlist['f*'][j],
                                            mlist[metric][j]))
                        mlast[metric] = mlist[metric][j]
                    f_last = vlist['f*'][j]
        # check monotonicity with q*
        for c in c_unique_list:
            for f in f_unique_list:
                q_last = 0
                mlast = dict()
                for metric in metrics:
                    mlast[metric] = 0.0
                indices = np.where((vlist['c*'] == c) & (vlist['f*'] == f))[0]
                for i, j in enumerate(indices):
                    for metric in metrics:
                        if i != 0:
                            if mono[metric]['q*'] == 0:
                                if vlist['q*'][j] > q_last and mlist[metric][j] > mlast[metric]:
                                    mono[metric]['q*'] = 1
                                elif vlist['q*'][j] > q_last and mlist[metric][j] < mlast[metric]:
                                    mono[metric]['q*'] = -1
                            elif mono[metric]['q*'] == 1:
                                if vlist['q*'][j] > q_last and mlast[metric] - mlist[metric][j] > utils.MARGIN_ERROR:
                                    mono[metric]['q*'] = -2
                                    violations.append(
                                        '{expected: ↑, (c*, f*): (%f, %d), last (q*, %s): (%d, %f), current (q*, '
                                        '%s): (%d, %f)}'
                                        % (
                                            c, f, metric, q_last, mlast[metric], metric, vlist['q*'][j],
                                            mlist[metric][j]))
                            elif mono[metric]['q*'] == -1:
                                if vlist['q*'][j] > q_last and mlist[metric][j] - mlast[metric] > utils.MARGIN_ERROR:
                                    mono[metric]['q*'] = 2
                                    violations.append(
                                        '{expected: ↓, (c*, f*): (%f, %d), last (q*, %s): (%d, %f), current (q*, '
                                        '%s): (%d, %f)}'
                                        % (
                                            c, f, metric, q_last, mlast[metric], metric, vlist['q*'][j],
                                            mlist[metric][j]))
                        mlast[metric] = mlist[metric][j]
                    q_last = vlist['q*'][j]
    if ftype == '2d':  # check 2d file
        # check monotonicity with c*
        for f in f_unique_list:
            c_last = 0.0
            mlast = dict()
            for metric in metrics:
                mlast[metric] = 0.0
            indices = np.where(vlist['f*'] == f)[0]
            for i, j in enumerate(indices):
                for metric in metrics:
                    if i != 0:
                        if mono[metric]['c*'] == 0:
                            if vlist['c*'][j] > c_last and mlist[metric][j] > mlast[metric]:
                                mono[metric]['c*'] = 1
                            elif vlist['c*'][j] > c_last and mlist[metric][j] < mlast[metric]:
                                mono[metric]['c*'] = -1
                        elif mono[metric]['c*'] == 1:
                            if vlist['c*'][j] > c_last and mlast[metric] - mlist[metric][j] > utils.MARGIN_ERROR:
                                mono[metric]['c*'] = -2
                                violations.append(
                                    '{expected: ↑, f*: %d, last (c*, %s): (%f, %f), current (c*, %s): (%f, %f)}'
                                    % (f, metric, c_last, mlast[metric], metric, vlist['c*'][j], mlist[metric][j]))
                        elif mono[metric]['c*'] == -1:
                            if vlist['c*'][j] > c_last and mlist[metric][j] - mlast[metric] > utils.MARGIN_ERROR:
                                mono[metric]['c*'] = 2
                                violations.append(
                                    '{expected: ↓, f*: %d, last (c*, %s): (%f, %f), current (c*, %s): (%f, %f)}'
                                    % (f, metric, c_last, mlast[metric], metric, vlist['c*'][j], mlist[metric][j]))
                    mlast[metric] = mlist[metric][j]
                c_last = vlist['c*'][j]
        # check monotonicity with f*
        for c in c_unique_list:
            f_last = 0
            mlast = dict()
            for metric in metrics:
                mlast[metric] = 0.0
            indices = np.where(vlist['c*'] == c)[0]
            for i, j in enumerate(indices):
                for metric in metrics:
                    if i != 0:
                        if mono[metric]['f*'] == 0:
                            if vlist['f*'][j] > f_last and mlist[metric][j] > mlast[metric]:
                                mono[metric]['f*'] = 1
                            elif vlist['f*'][j] > f_last and mlist[metric][j] < mlast[metric]:
                                mono[metric]['f*'] = -1
                        elif mono[metric]['f*'] == 1:
                            if vlist['f*'][j] > f_last and mlast[metric] - mlist[metric][j] > utils.MARGIN_ERROR:
                                mono[metric]['f*'] = -2
                                violations.append(
                                    '{expected: ↑, c*: %f, last (f*, %s): (%d, %f), current (f*, %s): (%d, %f)}'
                                    % (c, metric, f_last, mlast[metric], metric, vlist['f*'][j], mlist[metric][j]))
                        elif mono[metric]['f*'] == -1:
                            if vlist['f*'][j] > f_last and mlist[metric][j] - mlast[metric] > utils.MARGIN_ERROR:
                                mono[metric]['f*'] = 2
                                violations.append(
                                    '{expected: ↓, c*: %d, last (f*, %s): (%d, %f), current (f*, %s): (%d, %f)}'
                                    % (c, metric, f_last, mlast[metric], metric, vlist['f*'][j], mlist[metric][j]))
                    mlast[metric] = mlist[metric][j]
                f_last = vlist['f*'][j]
    return mono, violations


def qm_data_vis(file: str, plot_type: str = '3d', z_data: str = 'w', interp: bool = True, samples: int = 1000,
                dpi: int = 150):
    supported_plot_type = ['c', 'f', '3d']
    if plot_type not in supported_plot_type:
        raise ValueError(f'plot_type must be one of {supported_plot_type}, received {plot_type} instead')
    supported_z_data = ['p_r', 'w', 'l', 'w_q', 'l_q', 'w_e', 'l_e']
    if z_data not in supported_z_data:
        raise ValueError(f'z_data must be one of {supported_z_data}, received {z_data} instead')
    if interp and (not isinstance(samples, int) or samples <= 0):
        raise ValueError('invalid samples, if interp, samples must be a positive integer')
    # params
    delta_t = 0
    req_num = 0
    total_load = 0.0
    precision = 0
    error = 0.0
    # data
    c_list = []
    f_list = []
    p_0_list = []
    l_list = []
    w_list = []
    l_q_list = []
    w_q_list = []
    c_limit = 0.0
    f_limit = []
    # read file
    with open(file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    for line in lines:
        line = line.strip()
        # read params
        if line.startswith('Delta t'):
            delta_t = int(line.split('=')[1].split('ms')[0])
        elif line.startswith('Number of requests'):
            req_num = int(line.split('=')[1])
        elif line.startswith('Total load'):
            total_load = float(line.split('=')[1].split('ms')[0])
        elif line.startswith('Precision'):
            precision = int(line.split('=')[1])
        elif line.startswith('Error'):
            error = float(line.split('=')[1])
        elif line.startswith('CPU lower bound'):
            c_limit = float(line.split('=')[1])
        elif line.startswith('Flow control limits'):
            f_limits_str = line.split('=')[1].split('[')[1].split(']')[0]
            for f_limit_str in f_limits_str.split(','):
                f_limit.append(float(f_limit_str))
        # read data
        elif line.startswith('c*'):
            c_list.append(float(line.split('=')[1]))
        elif line.startswith('f*'):
            f_list.append(int(line.split('=')[1]))
        elif line.startswith('overload'):
            # f_limit = f_list.pop()
            f_list.pop()
            c_list.pop()
        elif line.startswith('p_0('):
            p_0_list.append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L('):
            l_list.append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W('):
            w_list.append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L_q('):
            l_q_list.append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W_q('):
            w_q_list.append(decimal.Decimal(line.split('≈')[1]))
    c_list = np.array(c_list).astype(float)
    f_list = np.array(f_list).astype(int)
    p_0_list = np.array(p_0_list).astype(float)
    l_list = np.array(l_list).astype(float)
    w_list = np.array(w_list).astype(float)
    l_q_list = np.array(l_q_list).astype(float)
    w_q_list = np.array(w_q_list).astype(float)
    l_e_list = np.subtract(l_list, l_q_list)
    w_e_list = np.subtract(w_list, w_q_list)
    # z(y) data for 3d(2d) plot
    if z_data in ['w', 'w_q', 'w_e', 'l', 'l_q', 'l_e']:
        if z_data == 'w':
            z = w_list
            z_label = 'W (ms)'
            z_title = 'Mean Latency of Requests'
        elif z_data == 'w_q':
            z = w_q_list
            z_label = 'W_q (ms)'
            z_title = 'Mean Queuing Time of Requests'
        elif z_data == 'w_e':
            z = w_e_list
            z_label = 'W_e (ms)'
            z_title = 'Mean Executing Time of Requests'
        elif z_data == 'l':
            z = l_list
            z_label = 'L'
            z_title = 'Mean Number of Requests in the System'
        elif z_data == 'l_q':
            z = l_q_list
            z_label = 'L_q'
            z_title = 'Mean Number of Queuing Requests'
        else:
            z = l_e_list
            z_label = 'L_e'
            z_title = 'Mean Number of Executing Requests'
        z_limit = np.linspace(max(0, math.floor(z.min())), math.ceil(z.max()), 2)
    else:  # p_0
        z = p_0_list
        z_label = 'p_0'
        z_title = 'The Probability That the System Is Empty'
        z_limit = np.linspace(z.min() * 0.9, z.max() * 1.1, 2)
    if plot_type == '3d':
        my_cmap = sns.color_palette('plasma', as_cmap=True)
        fig = plt.figure(dpi=dpi)
        ax = fig.add_subplot(111, projection='3d')
        # draw limit surfaces
        y_limit = np.linspace(np.log10(max(1, math.floor(f_limit[0]))), np.log10(f_list.max()) + 0.1, 2)
        x_limit = np.linspace(c_limit, math.ceil(c_list.max()), 2)
        Y_limit, Z_limit = np.meshgrid(y_limit, z_limit)
        X_limit = np.full(y_limit.shape, c_limit)
        ax.plot_surface(X_limit, Y_limit, Z_limit, color='black', alpha=0.5, edgecolor=None,  # type: ignore
                        label=f'c* limit={c_limit}core')
        X_limit, Z_limit = np.meshgrid(x_limit, z_limit)
        for f in f_limit:
            Y_limit = np.full(x_limit.shape, np.log10(max(1, math.floor(f))))
            ax.plot_surface(X_limit, Y_limit, Z_limit, color='grey', alpha=0.5, edgecolor=None,  # type: ignore
                            label=f'f* limit={math.floor(f)}')
        # no interpolation
        if not interp:
            plt.colorbar(ax.plot_trisurf(c_list, np.log10(f_list), z, cmap=my_cmap, edgecolor='None'))  # type: ignore
        # interpolate
        else:
            xi = np.linspace(c_list.min(), c_list.max(), samples)
            yi = np.logspace(np.log10(f_list.min()), np.log10(f_list.max()), samples)
            xi, yi = np.meshgrid(xi, np.log10(yi))
            zi = griddata((c_list, np.log10(f_list)), z, (xi, yi), method='linear')
            plt.colorbar(ax.plot_surface(xi, yi, zi, cmap=my_cmap, edgecolor='None'))  # type: ignore
        ax.legend()
        ax.set(xlabel='CPU allocation (core)', ylabel='log10(f*)', zlabel=z_label,
               title=f'{z_title}\n'
                     f'(t={delta_t}ms, #req={req_num}, ∑load={total_load}core·ms,\n'
                     f'precision={precision}, error={error})')
    else:  # 2d plot
        if plot_type == 'c':  # x: cpu allocation
            f_list_unique = np.unique(f_list)
            f_to_plot = []
            for i, f in enumerate(f_list_unique):
                # f_to_plot.append(f)
                if i <= 4 or i % 8 == 0 or i == len(f_list_unique) - 1:
                    f_to_plot.append(f)
            sns.set_palette('Spectral', len(f_to_plot))
            fig, ax = plt.subplots(layout='constrained')
            fig.set_dpi(dpi)
            c_dict = dict()
            y_dict = dict()
            for f in f_list_unique:
                c_temp = []
                y_temp = []
                indices = np.where(f_list == f)[0]
                for i in indices:
                    c_temp.append(c_list[i])
                    y_temp.append(z[i])
                c_dict[f] = np.array(c_temp)
                y_dict[f] = np.array(y_temp)
            # draw limit line
            ax.annotate(f'limit c*={c_limit}', xy=(c_limit, z.max()), xytext=(c_limit + 0.1, z.max()))
            for f in f_to_plot:
                ax.plot(c_dict[f], y_dict[f], label=f'f*={f}')
            ax.set(xlabel='CPU allocation (core)', ylabel=z_label,
                   title=f'{z_title}\n'
                         f'(t={delta_t}ms, #req={req_num}, ∑load={total_load}core·ms,\n'
                         f'precision={precision}, error={error})')
            ax.axvline(x=c_limit, linestyle='--', color='black')
        else:  # x: max allowed concurrent executing requests
            c_list_unique = np.unique(c_list)
            c_to_plot = []
            for i, c in enumerate(c_list_unique):
                # c_to_plot.append(c)
                if i % 3 == 0 or i == len(c_list_unique) - 1:
                    c_to_plot.append(c)
            sns.set_palette('Spectral', len(c_to_plot))
            fig, ax = plt.subplots(layout='constrained')
            fig.set_dpi(dpi)
            f_dict = dict()
            y_dict = dict()
            for c in c_list_unique:
                f_temp = []
                y_temp = []
                indices = np.where(c_list == c)[0]
                for i in indices:
                    f_temp.append(f_list[i])
                    y_temp.append(z[i])
                f_dict[c] = np.array(f_temp)
                y_dict[c] = np.array(y_temp)
            for c in c_to_plot:
                ax.plot(f_dict[c], y_dict[c], label=f'c*={c}core')
            ax.set(xlabel='f*', xscale='log', ylabel=z_label,
                   title=f'{z_title}\n'
                         f'(t={delta_t}ms, #req={req_num}, ∑load={total_load}core·ms,\n'
                         f'precision={precision}, error={error})')
            for f in f_limit:
                ax.annotate(f'limit f*={math.floor(f)}', xy=(math.floor(f), z.max()),
                            xytext=(math.floor(f) + 0.1, z.max()))
                ax.axvline(x=math.floor(f), linestyle='--', color='black')
        fig.legend(ncol=3, loc='outside lower center')


def qm_data_vis_3d(file: str, plot_type: str = '3d', x_var: str = 'c', y_var: str = 'f', fix_value: int | float = 0,
                   z_metric: str = 'w', interp: bool = True, samples: int = 1000, dpi: int = 150):
    # constants
    supported_plt_type = ['2d', '3d']
    supported_ind_var = ['c', 'f', 'q']
    supported_z_metric = ['p_r', 'l', 'w', 'l_q', 'w_q', 'l_e', 'w_e']
    if plot_type not in supported_plt_type:
        raise ValueError(f'plot_type must be one of {supported_plt_type}, received {plot_type} instead')
    if x_var not in supported_ind_var:
        raise ValueError(f'x_var must be one of {supported_ind_var}, received {x_var} instead')
    if y_var not in supported_ind_var:
        raise ValueError(f'y_var must be one of {supported_ind_var}, received {y_var} instead')
    if x_var == y_var:
        raise ValueError('x, y variable cannot be the same')
    if type(fix_value) not in [int, float]:
        raise ValueError(f'fix_value must be int or float, received {fix_value} ({type(fix_value)}) instead')
    if z_metric not in supported_z_metric:
        raise ValueError(f'z_metric must be one of {supported_z_metric}, received {z_metric} instead')
    if interp and (not isinstance(samples, int) or samples <= 0):
        raise ValueError('invalid samples, if interp, samples must be a positive integer')
    # params
    delta_t = 0
    req_num = 0
    total_load = 0.0
    precision = 0
    error = 0.0
    # limits
    c_limit = 0.0
    f_limit = []
    # data
    vlist = {}
    for var in supported_ind_var:
        vlist[var] = []
    mlist = {}
    for metric in supported_z_metric:
        mlist[metric] = []
    # read file
    with open(file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    for line in lines:
        line = line.strip()
        # read params
        if line.startswith('Delta t'):
            delta_t = int(line.split('=')[1].split('ms')[0])
        elif line.startswith('Number of requests'):
            req_num = int(line.split('=')[1])
        elif line.startswith('Total load'):
            total_load = float(line.split('=')[1].split('ms')[0])
        elif line.startswith('Precision'):
            precision = int(line.split('=')[1])
        elif line.startswith('CPU lower bound'):
            c_limit = float(line.split('=')[1])
        elif line.startswith('Flow control limits'):
            f_limits_str = line.split('=')[1].split('[')[1].split(']')[0]
            for f_limit_str in f_limits_str.split(','):
                f_limit.append(float(f_limit_str))
        # read data
        elif line.startswith('c*'):
            vlist['c'].append(float(line.split('=')[1]))
        elif line.startswith('f*'):
            vlist['f'].append(int(line.split('=')[1]))
        elif line.startswith('q*'):
            vlist['q'].append(int(line.split('=')[1]))
        elif line.startswith('overload'):
            for var in supported_ind_var:
                vlist[var].pop()
        elif line.startswith('p_reject('):
            mlist['p_r'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L('):
            mlist['l'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W('):
            mlist['w'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('L_q('):
            mlist['l_q'].append(decimal.Decimal(line.split('≈')[1]))
        elif line.startswith('W_q('):
            mlist['w_q'].append(decimal.Decimal(line.split('≈')[1]))
    for var in supported_ind_var:
        if var == 'c':
            vlist[var] = np.array(vlist[var]).astype(float)
        else:
            vlist[var] = np.array(vlist[var]).astype(int)
    for metric in supported_z_metric:
        if metric == 'l_e':
            mlist[metric] = np.subtract(mlist['l'], mlist['l_q'])
        elif metric == 'w_e':
            mlist[metric] = np.subtract(mlist['w'], mlist['w_q'])
        else:
            mlist[metric] = np.array(mlist[metric]).astype(float)
    # z metric for plot
    if z_metric == 'w':
        z = mlist['w']
        z_label = 'W (ms)'
        z_title = 'Mean Latency of Requests'
    elif z_metric == 'w_q':
        z = mlist['w_q']
        z_label = 'W_q (ms)'
        z_title = 'Mean Queuing Time of Requests'
    elif z_metric == 'w_e':
        z = mlist['w_e']
        z_label = 'W_e (ms)'
        z_title = 'Mean Executing Time of Requests'
    elif z_metric == 'l':
        z = mlist['l']
        z_label = 'L'
        z_title = 'Mean Number of Requests in the System'
    elif z_metric == 'l_q':
        z = mlist['l_q']
        z_label = 'L_q'
        z_title = 'Mean Number of Queuing Requests'
    elif z_metric == 'l_e':
        z = mlist['l_e']
        z_label = 'L_e'
        z_title = 'Mean Number of Executing Requests'
    else:
        z = mlist['p_r']
        z_label = 'p_r'
        z_title = 'The Probability That A Request Is Rejected'
    # x, y metric and fix value for plot
    # c_label = 'CPU allocation (core)'
    c_label = 'c*'
    # f_label = 'max concurrent executing requests'
    f_label = 'f*'
    # q_label = 'max queue length'
    q_label = 'q*'
    if x_var == 'f':
        x_label = f_label
        # x = np.log10(vlist['f'])
        x = vlist['f']
        if y_var == 'c':
            y_label = c_label
            y = vlist['c']
            fix_var = 'q*'
            selected = np.isclose(vlist['q'], fix_value)
        else:
            y_label = q_label
            y = vlist['q']
            fix_var = 'c*'
            selected = np.isclose(vlist['c'], fix_value)
    elif x_var == 'c':
        x = vlist['c']
        x_label = c_label
        if y_var == 'f':
            y_label = f_label
            # y = np.log10(vlist['f'])
            y = vlist['f']
            fix_var = 'q*'
            selected = np.isclose(vlist['q'], fix_value)
        else:
            y_label = q_label
            y = vlist['q']
            fix_var = 'f*'
            selected = np.isclose(vlist['f'], fix_value)
    else:
        x = vlist['q']
        x_label = q_label
        if y_var == 'c':
            y_label = c_label
            y = vlist['c']
            fix_var = 'f*'
            selected = np.isclose(vlist['f'], fix_value)
        else:
            y_label = f_label
            # y = np.log10(vlist['f'])
            y = vlist['f']
            fix_var = 'c*'
            selected = np.isclose(vlist['c'], fix_value)
    x_selected = x[selected]
    y_selected = y[selected]
    z_selected = z[selected]
    if len(x_selected) == 0:
        raise ValueError('invalid fix value, no samples for that value')
    # 3d plot
    if plot_type == '3d':
        cmap = sns.color_palette('plasma', as_cmap=True)
        fig = plt.figure(dpi=dpi)
        ax = fig.add_subplot(111, projection='3d')
        # draw limit surfaces
        if z_metric == 'p_r':
            z_limit = np.linspace(z_selected.min() * 0.9, z_selected.max() * 1.1, 2)
        else:
            z_limit = np.linspace(max(0, math.floor(z_selected.min())), math.ceil(z_selected.max()), 2)
        # f_limit_surface = np.linspace(np.log10(max(1, math.floor(f_limit[0]))), np.log10(vlist['f'].max()) + 0.1, 2)
        f_limit_surface = np.linspace(math.floor(vlist['f'].min()), math.ceil(vlist['f'].max()), 2)
        c_limit_surface = np.linspace(c_limit, math.ceil(vlist['c'].max()), 2)
        q_limit_surface = np.linspace(math.floor(vlist['q'].min()), math.ceil(vlist['q'].max()), 2)
        # draw limit surfaces for x var
        if x_var == 'f':
            if y_var == 'c':
                y_limit = c_limit_surface
            else:
                y_limit = q_limit_surface
            y_grid, z_grid = np.meshgrid(y_limit, z_limit)
            for f in f_limit:
                # x_surface = np.full(y_limit.shape, np.log10(max(1, math.floor(f))))
                x_surface = np.full(y_limit.shape, math.floor(f))
                ax.plot_surface(x_surface, y_limit, z_grid, color='black', alpha=0.5, edgecolor=None,  # type: ignore
                                label=f'f* limit={math.floor(f)}')
        elif x_var == 'c':
            if y_var == 'f':
                y_limit = f_limit_surface
            else:
                y_limit = q_limit_surface
            y_grid, z_grid = np.meshgrid(y_limit, z_limit)
            x_surface = np.full(y_limit.shape, c_limit)
            ax.plot_surface(x_surface, y_grid, z_grid, color='grey', alpha=0.5, edgecolor=None,  # type: ignore
                            label=f'c* limit={c_limit}core')
        # draw limit surfaces for y var
        if y_var == 'f':
            if x_var == 'c':
                x_limit = c_limit_surface
            else:
                x_limit = q_limit_surface
            x_grid, z_grid = np.meshgrid(x_limit, z_limit)
            for f in f_limit:
                # y_surface = np.full(x_limit.shape, np.log10(max(1, math.floor(f))))
                y_surface = np.full(x_limit.shape, math.floor(f))
                ax.plot_surface(x_limit, y_surface, z_grid, color='black', alpha=0.5, edgecolor=None,  # type: ignore
                                label=f'f* limit={math.floor(f)}')
        elif y_var == 'c':
            if x_var == 'f':
                x_limit = f_limit_surface
            else:
                x_limit = q_limit_surface
            x_grid, z_grid = np.meshgrid(x_limit, z_limit)
            y_surface = np.full(x_limit.shape, c_limit)
            ax.plot_surface(x_limit, y_surface, z_grid, color='grey', alpha=0.5, edgecolor=None,  # type: ignore
                            label=f'c* limit={c_limit}core')
        # draw metric surface with fix value
        if interp:
            xi = np.linspace(x_selected.min(), x_selected.max(), samples)
            yi = np.linspace(y_selected.min(), y_selected.max(), samples)
            xi_grid, yi_grid = np.meshgrid(xi, yi)
            zi = griddata((x_selected, y_selected), z_selected, (xi_grid, yi_grid), method='linear')
            plt.colorbar(ax.plot_surface(xi_grid, yi_grid, zi, cmap=cmap, edgecolor='None'))  # type: ignore
        else:
            plt.colorbar(
                ax.plot_trisurf(x_selected, y_selected, z_selected, cmap=cmap, edgecolor='None'))  # type: ignore
        ax.legend()
        ax.set(xlabel=x_label, ylabel=y_label, zlabel=z_label,
               title=f'{z_title}\n'
                     f'(t={delta_t}ms, #req={req_num}, ∑load={total_load}core·ms,\n'
                     f'precision={precision}, fixed {fix_var}={fix_value})')
    # 2d plot
    else:
        y_to_plot = []
        y_unique = np.unique(y_selected)
        for i, y in enumerate(y_unique):
            # if y == 50:
            if i <= 4 or i % 4 == 0 or i == len(y_unique) - 1:
                y_to_plot.append(y)
        sns.set_palette('Spectral', len(y_to_plot))
        fig, ax = plt.subplots(layout='constrained')
        # draw plots
        for y in y_to_plot:
            indices = np.where(y_selected == y)[0]
            ax.plot(x_selected[indices], z_selected[indices], label=f'{y_var}*={y}')
        # draw limit lines
        if x_var == 'c':
            ax.axvline(x=c_limit, linestyle='--', color='grey')
            ax.annotate(f'limit c*={c_limit}', xy=(c_limit, z_selected.max()), xytext=(c_limit + 0.1, z_selected.max()))
        if x_var == 'f':
            for f in f_limit:
                ax.axvline(x=math.floor(f), linestyle='--', color='black')
                ax.annotate(f'limit f*={math.floor(f)}', xy=(math.floor(f), z_selected.max()),
                            xytext=(math.floor(f) + 0.1, z_selected.max()))
        # if x_var == 'f':
        #     ax.set(xscale='log')
        ax.set(xlabel=x_label, ylabel=z_label, title=f'{z_title}\n'
                                                     f'(t={delta_t}ms, #req={req_num}, ∑load={total_load}core·ms,\n'
                                                     f'precision={precision}, fix {fix_var}={fix_value})')
        fig.legend(ncol=4, loc='outside lower center')
